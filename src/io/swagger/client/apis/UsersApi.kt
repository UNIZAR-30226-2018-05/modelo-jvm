/**
* Proyecto Cierzo API
* Back-end API del Proyecto Cierzo
*
* OpenAPI spec version: 2.0.0
* 
*
* NOTE: This class is auto generated by the swagger code generator program.
* https://github.com/swagger-api/swagger-codegen.git
* Do not edit the class manually.
*/
package io.swagger.client.apis

import io.swagger.client.models.AccountItem
import io.swagger.client.models.AccountItemUpdate
import io.swagger.client.models.LoginItem
import io.swagger.client.models.PlaylistItem
import io.swagger.client.models.PlaylistItemNew
import io.swagger.client.models.SessionItem

import io.swagger.client.infrastructure.*

class UsersApi(basePath: kotlin.String = "https://virtserver.swaggerhub.com/miguescri/ProySoft/1.0.0") : ApiClient(basePath) {

    /**
    * crea una lista de reproducción
    * Un usuario crea una lista de reproducción.
    * @param playlistItem Playlist item to add (optional)
    * @return PlaylistItem
    */
    @Suppress("UNCHECKED_CAST")
    fun addPlaylist(playlistItem: PlaylistItemNew) : PlaylistItem {
        val localVariableBody: kotlin.Any? = playlistItem
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/playlists",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<PlaylistItem>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as PlaylistItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * añade una canción a una lista de reproducción
    * Un usuario añade una canción a una lista de reproducción de su propiedad.
    * @param playlistID ID de la playlist 
    * @param songID Song to add (optional)
    * @return PlaylistItem
    */
    @Suppress("UNCHECKED_CAST")
    fun addPlaylistSong(playlistID: kotlin.String, songID: kotlin.String) : PlaylistItem {
        val localVariableBody: kotlin.Any? = songID
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/playlists{playlistID}/songs".replace("{"+"playlistID"+"}", "$playlistID"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<PlaylistItem>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as PlaylistItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * borra la cuenta del usuario
    * Elimina definitivamente la cuenta del usuario. No se puede deshacer. No funciona con cuentas de administrador 
    * @return void
    */
    fun deleteAccount() : Unit {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.DELETE,
            "/account",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * elimina una playlist
    * Elimina la playlist identificada por playlistID 
    * @param playlistID ID de la playlist 
    * @return void
    */
    fun deletePlaylist(playlistID: kotlin.String) : Unit {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.DELETE,
            "/playlists/{playlistID}".replace("{"+"playlistID"+"}", "$playlistID"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * elimina una canción de una playlist identificada por playlistID
    * Elimina una canción de la playlist identificada por playlistID 
    * @param playlistID ID de la playlist 
    * @param songID ID de la canción 
    * @return void
    */
    fun deletePlaylistSong(playlistID: kotlin.String, songID: kotlin.String) : Unit {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.DELETE,
            "/playlists/{playlistID}/songs/{songID}".replace("{"+"playlistID"+"}", "$playlistID").replace("{"+"songID"+"}", "$songID"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * comienza a seguir al usuario identificado por profileID
    * Comienza a seguir al usuario identificado por profileID
    * @param profileID ID del perfil 
    * @return void
    */
    fun followProfile(profileID: kotlin.String) : Unit {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/profiles/{profileID}/follow".replace("{"+"profileID"+"}", "$profileID"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * devuelve la información de la cuenta del usuario
    * Devuelve la información de la cuenta del usuario. 
    * @return AccountItem
    */
    @Suppress("UNCHECKED_CAST")
    fun getAccount() : AccountItem {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/account",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<AccountItem>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as AccountItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * cierra sesión de usuario
    * Cierra la sesión de usuario
    * @return void
    */
    fun logout() : Unit {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.DELETE,
            "/login",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * devuelve información de sincronización de canciones
    * Devuelve la lista de reproducción, la canción y el segundo que estaba escuchando el usuario previamente 
    * @return SessionItem
    */
    @Suppress("UNCHECKED_CAST")
    fun restoreSession() : SessionItem {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/account/session",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<SessionItem>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as SessionItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * guarda información de sincronización de canciones
    * Guarda la lista de reproducción, la canción y el segundo que está escuchando el usuario
    * @param sessionItem Datos a sincronizar (optional)
    * @return AccountItem
    */
    @Suppress("UNCHECKED_CAST")
    fun saveSession(sessionItem: SessionItem) : AccountItem {
        val localVariableBody: kotlin.Any? = sessionItem
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.PUT,
            "/account/session",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<AccountItem>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as AccountItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * deja de seguir al usuario identificado por profileID
    * Deja de seguir al usuario identificado por profileID 
    * @param profileID ID del perfil 
    * @return void
    */
    fun unfollowProfile(profileID: kotlin.String) : Unit {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.DELETE,
            "/profiles/{profileID}/follow".replace("{"+"profileID"+"}", "$profileID"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * actualiza información de cuenta de usuario
    * Actualiza la información de la cuenta del usuario. El campo \&quot;friends\&quot; de los amigos de un usuario está siempre vacío (valor NULL)
    * @param accountItem Datos a actualizar (optional)
    * @return AccountItem
    */
    @Suppress("UNCHECKED_CAST")
    fun updateAccount(accountItem: AccountItemUpdate) : AccountItem {
        val localVariableBody: kotlin.Any? = accountItem
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.PUT,
            "/account",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<AccountItem>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as AccountItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * modifica credenciales de acceso de cuenta de usuario
    * Modifica las credenciales de acceso de la cuenta del usuario. El campo \&quot;friends\&quot; de los amigos de un usuario está siempre vacío (valor NULL)
    * @param loginItem Datos a actualizar (optional)
    * @return AccountItem
    */
    @Suppress("UNCHECKED_CAST")
    fun updateAccountCredentials(loginItem: LoginItem) : AccountItem {
        val localVariableBody: kotlin.Any? = loginItem
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.PUT,
            "/account/credentials",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<AccountItem>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as AccountItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * actualiza la información de una playlist
    * Un usuario actualiza la información de una playlist de su propiedad.
    * @param playlistID ID de la playlist 
    * @param playlistItem Playlist item to update (optional)
    * @return PlaylistItem
    */
    @Suppress("UNCHECKED_CAST")
    fun updatePlaylist(playlistID: kotlin.String, playlistItem: PlaylistItemNew) : PlaylistItem {
        val localVariableBody: kotlin.Any? = playlistItem
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.PUT,
            "/playlists/{playlistID}".replace("{"+"playlistID"+"}", "$playlistID"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<PlaylistItem>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as PlaylistItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

}
