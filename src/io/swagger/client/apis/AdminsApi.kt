/**
* Proyecto Cierzo API
* Back-end API del Proyecto Cierzo
*
* OpenAPI spec version: 2.0.0
* 
*
* NOTE: This class is auto generated by the swagger code generator program.
* https://github.com/swagger-api/swagger-codegen.git
* Do not edit the class manually.
*/
package io.swagger.client.apis

import io.swagger.client.models.AlbumItem
import io.swagger.client.models.AlbumItemNew
import io.swagger.client.models.SongItem
import io.swagger.client.models.SongItemNew

import io.swagger.client.infrastructure.*

class AdminsApi(basePath: kotlin.String = "https://virtserver.swaggerhub.com/miguescri/ProySoft/1.0.0") : ApiClient(basePath) {

    /**
    * crea un álbum
    * Un administrador crea un álbum
    * @param albumItem Album item to add (optional)
    * @return AlbumItem
    */
    @Suppress("UNCHECKED_CAST")
    fun addAlbum(albumItem: AlbumItemNew) : AlbumItem {
        val localVariableBody: kotlin.Any? = albumItem
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/albums",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<AlbumItem>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as AlbumItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * añade una canción a un album
    * Un admin añade una canción a un album
    * @param albumID ID del album 
    * @param songID Song to add (optional)
    * @return AlbumItem
    */
    @Suppress("UNCHECKED_CAST")
    fun addAlbumSong(albumID: kotlin.String, songID: kotlin.String) : AlbumItem {
        val localVariableBody: kotlin.Any? = songID
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/albums/{albumID}/songs".replace("{"+"albumID"+"}", "$albumID"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<AlbumItem>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as AlbumItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * añade una canción
    * Un admin añade una canción a la base de datos.
    * @param songItem Song item to add (optional)
    * @return SongItem
    */
    @Suppress("UNCHECKED_CAST")
    fun addSong(songItem: SongItemNew) : SongItem {
        val localVariableBody: kotlin.Any? = songItem
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/songs",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<SongItem>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as SongItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * elimina un álbum
    * Elimina el álbum identificado por albumID 
    * @param albumID ID del álbum 
    * @return void
    */
    fun deleteAlbum(albumID: kotlin.String) : Unit {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.DELETE,
            "/albums/{albumID}".replace("{"+"albumID"+"}", "$albumID"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * elimina la carátula de un álbum
    * Elimina la carátula de un álbum identificadoa por albumID 
    * @param albumID ID del álbum 
    * @return void
    */
    fun deleteAlbumImage(albumID: kotlin.String) : Unit {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.DELETE,
            "/albums/{albumID}/image".replace("{"+"albumID"+"}", "$albumID"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * elimina la imagen de un autor
    * Elimina la imagen de un autor identificado por authorID 
    * @param authorID ID del autor 
    * @return void
    */
    fun deleteAuthorImage(authorID: kotlin.String) : Unit {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.DELETE,
            "/authors/{authorID}/image".replace("{"+"authorID"+"}", "$authorID"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * elimina una canción
    * Elimina información y fichero de  la canción identificada por songID 
    * @param songID ID de la canción 
    * @return void
    */
    fun deleteSong(songID: kotlin.String) : Unit {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.DELETE,
            "/songs/{songID}".replace("{"+"songID"+"}", "$songID"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * elimina el archivo de audio de una canción
    * Elimina el fichero de audio de una canción identificada por songID 
    * @param songID ID de la canción 
    * @return void
    */
    fun deleteSongFile(songID: kotlin.String) : Unit {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.DELETE,
            "/songs/{songID}/file".replace("{"+"songID"+"}", "$songID"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * elimina la carátula de una canción
    * Elimina la carátula de una canción identificada por songID 
    * @param songID ID de la canción 
    * @return void
    */
    fun deleteSongImage(songID: kotlin.String) : Unit {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.DELETE,
            "/songs/{songID}/image".replace("{"+"songID"+"}", "$songID"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * actualiza la información de una canción
    * Un admin actualiza la información de una canción.
    * @param songID ID de la canción 
    * @param songItem Song item to update (optional)
    * @return SongItem
    */
    @Suppress("UNCHECKED_CAST")
    fun updateSong(songID: kotlin.String, songItem: SongItemNew) : SongItem {
        val localVariableBody: kotlin.Any? = songItem
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.PUT,
            "/songs/{songID}".replace("{"+"songID"+"}", "$songID"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<SongItem>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as SongItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * carga la carátula de un álbum
    * Un admin carga la carátula de un álbum con identificador albumID.
    * @param albumID ID del álbum 
    * @param albumImage Album image to update 
    * @return void
    */
    fun uploadAlbumImage(albumID: kotlin.String, albumImage: java.io.File) : Unit {
        val localVariableBody: kotlin.Any? = mapOf("albumImage" to "$albumImage")
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf("Content-Type" to "multipart/form-data")
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/albums/{albumID}/image".replace("{"+"albumID"+"}", "$albumID"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * carga la imagen e un autor
    * Un admin carga la imagen de un autor con identificador authorID.
    * @param authorID ID del autor 
    * @param authorImage Image item to update 
    * @return void
    */
    fun uploadAuthorImage(authorID: kotlin.String, authorImage: java.io.File) : Unit {
        val localVariableBody: kotlin.Any? = mapOf("authorImage" to "$authorImage")
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf("Content-Type" to "multipart/form-data")
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/authors/{authorID}/image".replace("{"+"authorID"+"}", "$authorID"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * carga el archivo de audio de una canción
    * Un admin carga el archivo de audio de una canción con identificador songID.
    * @param songID ID de la canción 
    * @param songFile Song item to update 
    * @return void
    */
    fun uploadSongFile(songID: kotlin.String, songFile: java.io.File) : Unit {
        val localVariableBody: kotlin.Any? = mapOf("songFile" to "$songFile")
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf("Content-Type" to "multipart/form-data")
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/songs/{songID}/file".replace("{"+"songID"+"}", "$songID"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * carga la carátula de una canción
    * Un admin carga la carátula de una canción con identificador songID.
    * @param songID ID de la canción 
    * @param songImage Image item to update 
    * @return void
    */
    fun uploadSongImage(songID: kotlin.String, songImage: java.io.File) : Unit {
        val localVariableBody: kotlin.Any? = mapOf("songImage" to "$songImage")
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf("Content-Type" to "multipart/form-data")
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/songs/{songID}/image".replace("{"+"songID"+"}", "$songID"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

}
