/**
* Proyecto Cierzo API
* Back-end API del Proyecto Cierzo
*
* OpenAPI spec version: 2.0.0
* 
*
* NOTE: This class is auto generated by the swagger code generator program.
* https://github.com/swagger-api/swagger-codegen.git
* Do not edit the class manually.
*/
package io.swagger.client.apis

import io.swagger.client.models.AccountItem
import io.swagger.client.models.AlbumItem
import io.swagger.client.models.AuthorItem
import io.swagger.client.models.LoginItem
import io.swagger.client.models.PlaylistItem
import io.swagger.client.models.ProfileItem
import io.swagger.client.models.SignUpItem
import io.swagger.client.models.SongItem

import io.swagger.client.infrastructure.*

class PublicApi(basePath: kotlin.String = "https://virtserver.swaggerhub.com/miguescri/ProySoft/1.0.0") : ApiClient(basePath) {

    /**
    * crea cuenta de usuario
    * Crea una cuenta de usuario
    * @param signupItem Datos de la nueva cuenta (optional)
    * @return AccountItem
    */
    @Suppress("UNCHECKED_CAST")
    fun createAccount(signupItem: SignUpItem) : AccountItem {
        val localVariableBody: kotlin.Any? = signupItem
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/signup",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<AccountItem>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as AccountItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * obtiene un álbum
    * Obtiene los datos del álbum identificada por albumID 
    * @param albumID ID del álbum 
    * @return AlbumItem
    */
    @Suppress("UNCHECKED_CAST")
    fun getAlbum(albumID: kotlin.String) : AlbumItem {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/albums/{albumID}".replace("{"+"albumID"+"}", "$albumID"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<AlbumItem>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as AlbumItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * obtiene la carátula de un álbum
    * Obtiene la carátula de un álbum identificado por albumID 
    * @param albumID ID del álbum 
    * @return java.io.File
    */
    @Suppress("UNCHECKED_CAST")
    fun getAlbumImage(albumID: kotlin.String) : java.io.File {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/albums/{albumID}/image".replace("{"+"albumID"+"}", "$albumID"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<java.io.File>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as java.io.File
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * obtiene un perfil de autor identificado por authorID
    * Obtiene un perfil de autor identificado por authorID 
    * @param authorID ID del autor 
    * @return AuthorItem
    */
    @Suppress("UNCHECKED_CAST")
    fun getAuthor(authorID: kotlin.String) : AuthorItem {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/authors/{authorID}".replace("{"+"authorID"+"}", "$authorID"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<AuthorItem>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as AuthorItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * obtiene la imagen de un autor
    * Obtiene la imagen de un autor identificado por authorID 
    * @param authorID ID del autor 
    * @return java.io.File
    */
    @Suppress("UNCHECKED_CAST")
    fun getAuthorImage(authorID: kotlin.String) : java.io.File {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/authors/{authorID}/image".replace("{"+"authorID"+"}", "$authorID"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<java.io.File>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as java.io.File
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * obtiene una playlist
    * Obtiene los datos de la playlist identificada por playlistID 
    * @param playlistID ID de la playlist 
    * @return PlaylistItem
    */
    @Suppress("UNCHECKED_CAST")
    fun getPlaylist(playlistID: kotlin.String) : PlaylistItem {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/playlists/{playlistID}".replace("{"+"playlistID"+"}", "$playlistID"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<PlaylistItem>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as PlaylistItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * obtiene un perfil de usuario identificado por profileID
    * Obtiene un perfil de usuario identificado por profileID. 
    * @param profileID ID del perfil 
    * @return ProfileItem
    */
    @Suppress("UNCHECKED_CAST")
    fun getProfile(profileID: kotlin.String) : ProfileItem {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/profiles/{profileID}".replace("{"+"profileID"+"}", "$profileID"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<ProfileItem>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ProfileItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * obtiene información de una canción
    * Obtiene los datos de la canción identificada por songID 
    * @param songID ID de la canción 
    * @return SongItem
    */
    @Suppress("UNCHECKED_CAST")
    fun getSong(songID: kotlin.String) : SongItem {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/songs/{songID}".replace("{"+"songID"+"}", "$songID"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<SongItem>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as SongItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * obtiene el archivo de audio de una canción
    * Obtiene el archivo de audio de la canción identificada por songID 
    * @param songID ID de la canción 
    * @return java.io.File
    */
    @Suppress("UNCHECKED_CAST")
    fun getSongFile(songID: kotlin.String) : java.io.File {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/songs/{songID}/file".replace("{"+"songID"+"}", "$songID"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<java.io.File>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as java.io.File
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * obtiene la carátula de una canción
    * Obtiene la carátula de la canción identificada por songID 
    * @param songID ID de la canción 
    * @return java.io.File
    */
    @Suppress("UNCHECKED_CAST")
    fun getSongImage(songID: kotlin.String) : java.io.File {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/songs/{songID}/image".replace("{"+"songID"+"}", "$songID"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<java.io.File>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as java.io.File
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * inicia sesión de usuario
    * Inicia sesión de usuario. El campo \&quot;friends\&quot; de los amigos de un usuario está siempre vacío (valor NULL)
    * @param loginItem Credenciales (optional)
    * @return AccountItem
    */
    @Suppress("UNCHECKED_CAST")
    fun login(loginItem: LoginItem) : AccountItem {
        val localVariableBody: kotlin.Any? = loginItem
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/login",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<AccountItem>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as AccountItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * busca álbunes con ciertos parámetros
    * Al pasarle ciertos parámetros devuelve álbunes que se ajusten a ellos 
    * @param name nombre del álbum (optional)
    * @param author autor del álbum (optional)
    * @param skip number of records to skip for pagination (optional)
    * @param limit maximum number of records to return (optional)
    * @return kotlin.Array<AlbumItem>
    */
    @Suppress("UNCHECKED_CAST")
    fun searchAlbum(name: kotlin.String, author: kotlin.String, skip: kotlin.Int, limit: kotlin.Int) : kotlin.Array<AlbumItem> {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("name" to listOf("$name"), "author" to listOf("$author"), "skip" to listOf("$skip"), "limit" to listOf("$limit"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/albums",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.Array<AlbumItem>>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<AlbumItem>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * busca autores con ciertos parámetros
    * Al pasarle ciertos parámetros devuelve autores que se ajusten a ellos 
    * @param name nombre del autor (optional)
    * @param skip number of records to skip for pagination (optional)
    * @param limit maximum number of records to return (optional)
    * @return kotlin.Array<AuthorItem>
    */
    @Suppress("UNCHECKED_CAST")
    fun searchAuthors(name: kotlin.String, skip: kotlin.Int, limit: kotlin.Int) : kotlin.Array<AuthorItem> {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("name" to listOf("$name"), "skip" to listOf("$skip"), "limit" to listOf("$limit"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/authors",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.Array<AuthorItem>>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<AuthorItem>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * busca listas de reproducción con ciertos parámetros
    * Al pasarle ciertos parámetros devuelve listas de reproducción que se ajusten a ellos 
    * @param name nombre de la lista (optional)
    * @param owner propietario de la lista (optional)
    * @param skip number of records to skip for pagination (optional)
    * @param limit maximum number of records to return (optional)
    * @return kotlin.Array<PlaylistItem>
    */
    @Suppress("UNCHECKED_CAST")
    fun searchPlaylist(name: kotlin.String, owner: kotlin.String, skip: kotlin.Int, limit: kotlin.Int) : kotlin.Array<PlaylistItem> {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("name" to listOf("$name"), "owner" to listOf("$owner"), "skip" to listOf("$skip"), "limit" to listOf("$limit"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/playlists",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.Array<PlaylistItem>>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<PlaylistItem>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * busca usuarios con ciertos parámetros
    * Al pasarle ciertos parámetros devuelve usuarios que se ajusten a ellos. 
    * @param name nombre del usuario (optional)
    * @param username username del usuario (optional)
    * @param skip number of records to skip for pagination (optional)
    * @param limit maximum number of records to return (optional)
    * @return kotlin.Array<ProfileItem>
    */
    @Suppress("UNCHECKED_CAST")
    fun searchProfiles(name: kotlin.String, username: kotlin.String, skip: kotlin.Int, limit: kotlin.Int) : kotlin.Array<ProfileItem> {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("name" to listOf("$name"), "username" to listOf("$username"), "skip" to listOf("$skip"), "limit" to listOf("$limit"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/profiles",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.Array<ProfileItem>>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<ProfileItem>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * busca canciones con ciertos parámetros
    * Al pasarle ciertos parámetros devuelve cancionese que se ajusten a ellos 
    * @param name nombre de la canción (optional)
    * @param author autor de la canción (optional)
    * @param genre genero de la canción (optional)
    * @param skip number of records to skip for pagination (optional)
    * @param limit maximum number of records to return (optional)
    * @return kotlin.Array<SongItem>
    */
    @Suppress("UNCHECKED_CAST")
    fun searchSong(name: kotlin.String, author: kotlin.String, genre: kotlin.String, skip: kotlin.Int, limit: kotlin.Int) : kotlin.Array<SongItem> {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("name" to listOf("$name"), "author" to listOf("$author"), "genre" to listOf("$genre"), "skip" to listOf("$skip"), "limit" to listOf("$limit"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/songs",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.Array<SongItem>>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<SongItem>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

}
